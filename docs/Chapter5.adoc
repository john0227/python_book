= Python Book
:toc:
:toclevels: 3
:toc-title:
:toc-placement: preamble
:sectnums:
:sectnumlevels: 3
:imagesDir: images
:stylesDir: stylesheets
:stylesheet: asciidoctor.css
:xrefstyle: full
:experimental:
:table-stripes: none
:table-grid: all

<<<

== Chapter 1

== Chapter 2

== Chapter 3

== Chapter 4

== Chapter 5 - _for_ and _while_ Loops

In computer programming, the basic building blocks of any program are variables, conditional statements, and iterations. We have learned the first two, and now, let's take a look at iterations in programming.

=== _for_ Loops

The first example of iterations in programming is _for_ loops. The structure is as follows:

.*Structure of a _for_ Loop*
[source,python]
----
1    for var in range(start*, stop, step*):
2       <action>
----

[NOTE]
`*` next to a variable indicates that it is optional.

_start_, _stop_, and _step_ are parameters for the `range` function that take in integer values.

* _start_ - starting integer of the range of numbers (optional)
* _stop_ - stopping integer of the range of numbers that is excluded (necessary)
* _step_ - increment integer value between two consecutive numbers in the range
** Cannot be set to zero (Python will raise an exception if done so)

If _start_ and _step_ are not specified, _start_ is defaulted to `0`, and _step_ is defaulted to `1`. Also, only integer values must be passed to all three parameters.

`var` will iterate, or loop, over the numbers generated by the `range` function. To understand this better, let's look at some examples.

.*_for_ Loop Example*
[source,python]
----
 1    print('for i in range(3):')
 2    for i in range(3):  # stop = 3
 3        print(i, end=' ')
 4
 5    print('\nfor j in range(3, 5):')
 6    for j in range(3, 5):  # start, stop = 3, 5
 7        print(j, end=' ')
 8
 9    print('\nfor k in range(0, 8, 2):')
10    for k in range(0, 8, 2):  # start, stop, step = 0, 8, 2
11        print(k, end=' ')
----

.*Output*
----
for i in range(3):
0 1 2
for j in range(3, 5):
3 4
for k in range(0, 8, 2):
0 2 4 6
----

*Explanation*

For lines 2-3, the variable `i` is iterating over a range of numbers from `0` to `2` - because `3` is exclusive. Therefore, in the output, ``0 1 2 `` is printed.

If we go in more depth, `range(3)` returns a _list-like_ object, which looks like `[0, 1, 2]`. The difference between a list and a `range` object is that the elements of a list is created first before use, and the numbers of a `range` object is created on the fly. This means that for a list with numbers from `0` to `999`, all 1000 numbers are created and allocated a space in the computer's memory, but for `range(1000)`, each number is created one by one at the start of each iteration.

[NOTE]
The `list()` function can be used to transform a `range` object to a list. For example, `list(range(3))` will give the list `[0, 1, 2]`.

Regardless, ultimately, `for i in range(3)` means that `i` will be iterating over the sequence `[0, 1, 2]`.

[%header,cols="^.^10%,^.^21%,^.^23%,^.^23%,^.^23%"]
|====
2+|  | Loop 1 | Loop 2 | Loop 3
| [fira-code]#*var*# | [fira-code]#i# | `i = 0` | `i = 1` | `i = 2`
| [fira-code]#*<action>*# | [fira-code]#print(i, end=' ')# | `print(0, end=' ')` | `print(1, end=' ')` | `print(2, end=' ')`
2+| [big fira-code]#*Output at end of each loop*# | `'0 '` | `'0 1 '` | `'0 1 2 '`
|====

At the start of loop `n`, the value of the ``n``^th^ element of the sequence is assigned to `i`. This means that the sequence is iterated through in the order of its elements. Therefore, the two sequences `[0, 1, 2]` and `[2, 0, 1]` will cause different behaviors when `i` iterates over them.

[TIP]
`for var in range(stop)` can also be used to loop through certain actions `stop` number of times. For example, `for i in range(3)` will cause the _for_ loop to loop 3 times.

For lines 6-7, `for j in range(3, 5)` indicates that `j` will be iterating over the sequence `[3, 4]`, where `5` is excluded. Therefore, ``3 4 `` is printed.

For lines 10-11, all _start_, _stop_, and _step_ are specified in `range(0, 8, 2)`. If we unravel this, the `range` function will return a sequence that starts from `0` and ends before `8` in steps of `2`. Therefore, the sequence would look like this `[0, 2, 4, 6]`. So ``0 2 4 6 `` is printed.

====
If you are familiar with arithmetic sequences, you can think of the `range` function as one that returns an arithmetic sequence where,

* _n_ = `ceil((end - start) / step)`
* _a~0~_ = `start`
* _a~n~_ = `end`
* _d_ = `step`
====

*Things to Note*

. _start_ and _step_ are optional parameters. If not provided, _start_ will be `0`, and _step_ will be `1`.
.. If one number is provided, it is assigned to _stop_. For example, in `range(3)`, _start_ is 0, _stop_ is 3, and _step_ is 1.
.. If two numbers are provided, they are assigned to _start_ and _stop_, in that order. For example, in `range(3, 5)`, _start_ is 3, _stop_ is 5, and _step_ is 1.
.. If all three numbers are provided, they are assigned to each parameter in given order. For example, in `range(1, 9, 2)`, _start_ is 1, _stop_ is 9, and _step_ is 2.
. If _step_ is negative, then you can iterate through a range of numbers in a _reverse_ order.
+
[source,python]
----
for i in range(3, 0, -1):
    print(i, end=' ')
# this will output '3 2 1 '
----
+
. If _start_ is greater than or equal to _stop_ (or less than if _step_ is negative), then the `range` function will return an empty sequence. Therefore, there will be nothing to iterate through, and essentially, that _for_ loop would be doing nothing.
.. For example, both `range(3, 1)` and `range(-3, -1, -1)` would return an empty sequence
. `<action>` inside the _for_ loop must be indented one level farther rightward than the _for_ loop statement.
.. For example, in the following _for_ loop:
+
[source,python]
----
for var in range(stop):
    <action1>
    <action2>
    <action3>
<action4>
----
+
Actions 1-3 are iterated over `stop` number of times. After the _for_ loop is exited, `<action4>` is executed _once_.
. You can have a _for_ loop inside a _for_ loop (called a nested _for_ loop), generally used to traverse two-dimensional lists (which is not important as of now).

.#*Exercise 5.1: Write your own _for_ loop*#
----
Q1. Write a for loop that prints out all negative odd numbers from -1 to -9 (both inclusive).

Q2. Write a for loop that prints out the square of numbers from 1 to 5 (inclusive).
        ex) Should print the numbers 1, 4, 9, 16, 25

Q3. Challenge: Write a for loop that prints out the following:
        *
        **
        ***
        ****
    Hint: Create another variable and change its value inside the loop.
----

.#*Answer*#
[source,python]
----
1    # Q1
2    for i in range(-1, -10, -2):
3        print(i)
4    # Q2
5    for x in range(1, 6):
6        print(x * x)  # or print(x ** 2)
7    # Q3
8    for i in range(4):
9        print('*' * i)
----

.#*Exercise 5.2: Guess the output*#
[source,python]
----
1    # Q1
2    mystery_num = 0
3    for i in range(5):
4        mystery_num += i
5    print(mystery_num)
----

.#*Answer*#
----
10
----

.#*Additional Remarks (Teacher's Ed.)*#
----
For Exercise 5.1 Q3, the student can use a nested for loop:

    for i in range(4):
        for j in range(i + 1):
            print('*', end='')
        print('')

but the preferred answer is faster.

For Exercise 5.2:

Q1 is a standard way to calculate the sum of all numbers in a list. range(5) can be replaced with any list with numbers.
----

==== _for_ Loop with _break_ and _else_

As you code more and more programs, there will come a time when you will want to end a loop early when a certain condition is met. For example, let's say you are searching for a student with a certain name. You have a list containing names of all the students of a school. If you write a program that allows the user to search for a student with a certain name, it may look like this:

.*Example Program*
[source,python]
----
1    students = [...]  # filled with names as strings
2    name_to_search = input('Name of student to search: ')
3    for name in students:
4        if name == name_to_search:
5            print('Student found. Name:', name)
6            ...
----

Now, let's assume the name you are searching for is `'John'`, and the list `students` looks like `['John', 'Anna', 'Simon', 'Justin', 'Rachel', 'Kevin']`. Then, the program will find the student in one iteration, which means the last 5 iterations are meaningless. We want the _for_ loop to stop iterating once we find the student we want. In order to do this, we can use the `break` keyword.

.*Example Program (Altered)*
[source,python]
----
1    students = [...]  # filled with names as strings
2    name_to_search = input('Name of student to search: ')
3    for name in students:
4        if name == name_to_search:
5            print('Student found. Name:', name)
6            break
----

What `break` does is that once the interpreter reads the keyword, it will break out of the current loop. So once the interpreter reaches line 6, it will break out of the _for_ loop (at line 3). This enhances efficiency and reduces meaningless iterations. If `break` is used inside nested _for_ loops, the interpreter will break out of the innermost _for_ loop that the keyword `break` is contained in.

[source,python]
----
for i in range(3):
    for j in range(3):  # break
        if j == 1:
            break

for i in range(3):  # break
    for j in range(3):
        print(j)
    if i == 1:
        break
----

.#*Exercise 5.3: Finish the program*#

Fill in the empty lines of the following programs.

.a) Print `i` until `i = 3`.
[source,python]
----
1    for i in range(10):
2        print(i)
3        ...
4        ...
5    # Output is equivalent to print(0, 1, 2, 3, sep='\n')
----

.b) Print elements of list until an even number is found.
[source,python]
----
1    lst = [3, 1, 11, 5, 4, 9, 12, 13]
2    for el in lst:
3        ...
4        ...
5        print(el)
6    # Output is equivalent to print(3, 1, 11, 5, sep='\n')
----

.c) Print elements of list until a negative number is found.
[source,python]
----
1    lst = [3, 1, 11, -5, 4, 9, -12, -13]
2    ...
3    ...
4    ...
5    ...
6    # Output is equivalent to print(3, 1, 11, sep='\n')
----

.#*Answer*#
[source,python]
----
# Part (a)
3    if i == 3:
4        break

# Part (b)
3    if el % 2 == 0:
4        break

# Part (c)
2    for el in lst:
3        if el < 0:
4            break
5        print(el)
----

You can also pair a _for_ loop with an _else_ statement to check if your loop has finished normally without breaking prematurely.

.*Example Usage 1*
[source,python]
----
for i in range(3):
    print(i)
else:
    print('did not break out of for loop')
----

.*Output*
----
0
1
2
did not break out of for loop
----

.*Example Usage 2*
[source,python]
----
for i in range(3):
    print(i)
    if i == 1:
        break
else:
    print('did not break out of for loop')
----

.*Output*
----
0
1
----

As these examples show, the _else_ block is evaluated only if the _for_ loop completed without breaking. This can be useful when checking *_if all_* and *_if any_* conditions. _if all_ conditions check if all elements of a sequence satisfy a certain condition. Likewise, _if any_ conditions check if at least one element of a sequence satisfies a certain condition.

Let's say you want to check if a list contains only even numbers. You want to print `True` if it does, and `False` if it does not. You can rephrase this into two equivalent statements:

. Print `True` _if all_ elements of a list are even, and `False` if not.
. Print `False` _if any_ element of a list is odd, and `True` if not.

Or if combined:

[start=3]
. Print `True` _if all_ elements of a list are even, and `False` _if any_ element of a list is odd.

When programming, we usually follow the logic of the second statement.

[source,python]
----
1    lst = [...]
2    for el in lst:
3        if el % 2 == 1:  # if any element is odd, print False
4            print(False)
5            break
6    else:  # if not, print True
7        print(True)
----

You can fill in the values for `lst` at line 1 and check the resulting output. In summary, the `else` block in conjunction with _for_ loops will allow you to check if the loop was terminated without breaking. However, later on, when dealing with _if all_ and _if any_ conditions, you may want to write a function/method instead (to be covered later).

.#*Exercise 5.4: Write your own program*#
----
Q1. Check if a list contains only odd numbers. Print ':)' if it does, and ':(' if it does not. You may create a list filled with arbitrary values.

Q2. Get a user input of one positive integer, and check if the number is prime or not. Print whether or not the number is a prime number. Assume that the user input is always valid.
----

.#*Answer*#
[source,python]
----
 1    # Q1
 2    lst = [...]  # arbitrary values
 3    for el in lst:
 4        if el % 2 == 0:
 5            print(':(')
 6            break
 7    else:
 8        print(':)')
 9
10    # Q2
11    n = int(input())
12    for i in range(2, int(n ** 0.5) + 1):  # or range(2, n)
13        if n % i == 0:
14            print(n, 'is not a prime number')
15            break
16    else:
17        print(n, 'is a prime number')
----

==== _for_ Loop with Iterables

Let's say we have a list with all the names of the students in a school, and we want to find a student named Peter. To do this, we need to check each item in the list one by one until we find the student with the name Peter. The act of going over each element of a list is called _traversing_ or _iterating_ through the list, and we can do this with _for_ loops.

`range(n)` can be used to iterate through a set pattern of numbers or to loop through `n` times, but we can use other iterables in place of `range()` to traverse through each element of that iterable.

Let's look at lists first:

.*_for_ Loop with Lists*
[source,python]
----
1    a = ['Hello', 'World', '!!']
2    for s in a:
3        print(s, end=' ')
----

.*Output*
----
Hello World !!
----

Let's try to imitate the behavior of the `count()` method with _for_ loops.

.*`count()` Execution*
[source,python]
----
1    def my_count(lst, x):
2        count = 0
3        for el in lst:
4            if el == x:
5                count += 1
6        return count
----

At line 3, we traverse over `lst` by assigning each element of `lst` to `el` one by one. At lines 4-5, if `el` is equal in value to the `x` we are trying to count, we increment the `count` variable by 1. After all elements are iterated through, we return the value of the `count` variable at line 6. As such, we can use _for_ loops to traverse through and operate on lists.

One common use of _for_ loops with lists is to find the maximum or minimum element of that list. Here is the example to find the maximum element of a list:

.*Finding the maximum element*
[source,python]
----
1    def my_max(lst):
2        max_el = lst[0]
3        for el in lst:
4            if el > max_el:
5                max_el = el
6        return max_el
----

At line 2, `max_el` is set to the first element of `lst`. While iterating through the list, line 4 checks if each element `el` is greater than the current `max_el`. If it is, then `max_el` is updated. At the end of each loop, `max_el` will be the maximum of all the elements currently covered. When the _for_ loop is finished, it would have iterated through all the elements. Hence, `max_el` will be the maximum element of the whole list.

Tuples and strings can be iterated through in a similar manner as lists. Doing so for tuples will iterate through each element whereas doing so for strings will iterate through each character. However, in order to iterate through a dictionary, you need to do things differently.

Remember that dictionaries have a _key-value_ pairing, so there are two values to iterate through. There are many ways to iterate through a dictionary, and we will cover two of them.

Here is the general format of the first method:

.*Traversing Dictionaries: Method 1*
[source,python]
----
1    dct = {...}  # filled with arbitrary values
2    for key in dct:
3        # use dict[key] to access value
----

In this format, we are iterating through all the _keys_ of a dictionary. To access the _value_, we need to retrieve it by using the _key_ as the index. Here is an example of its use:

.*Method 1 Example*
[source,python]
----
1    idt_pw_map = {
2        'user1' : 'abc123',
3        'user2' : 'def456',
4        'user3' : 'ghi789'
5    }
6    for idt in idt_pw_map:
7        print('ID: {}    PW: {}'.format(idt, idt_pw_map[idt]))
----

.*Output*
----
ID: user1    PW: abc123
ID: user2    PW: def456
ID: user3    PW: ghi789
----

However, this method does not explicitly show that we are looping through a dictionary because it shares the same format as other iterables. The following format is a more preferred method in Python:

.*Traversing Dictionaries: Method 2*
[source,python]
----
1    dct = {...}  # filled with arbitrary values
2    for key, value in dct.items():
3        # ...action
----

In this example, we use `items()`, a [fira-code]#dict# method. By using the `items()` method, we can iterate through both the `key` and `value` entries, explicitly showing that we are iterating through a dictionary. Here is an example of its use:

.*Method 2 Example*
[source,python]
----
1    idt_pw_map = {
2        'user1' : 'abc123',
3        'user2' : 'def456',
4        'user3' : 'ghi789'
5    }
6    for idt, pw in idt_pw_map.items():
7        print('ID: {}    PW: {}'.format(idt, pw))
----

.*Output*
----
ID: user1    PW: abc123
ID: user2    PW: def456
ID: user3    PW: ghi789
----

.#*Exercise 5.5: Write your own program*#
----
Q1. Write a program to find the minimum element of a given list.

Q2. Write a program to imitate the behavior of the in operator. In other words, make a function that checks if specified element is in the given iterable.

Q3. Challenge: Write a program to count the frequency of each character that appears in a string and return the result as a dictionary. For example, for the string 'banana', the return value would be (not in particular order):

        {'b': 1, 'a': 3, 'n': 2}

Hint: Iterate through the string and create new entries if a character is not in the dictionary yet. You can refer back to Chapter 3 for dictionary methods.

Q4. Challenge: Write a program to convert a dictionary to a list. Each KV pair is to be converted to a tuple. For example,

        {'b': 1, 'a': 3, 'n': 2} -> [('b', 1), ('a', 3), ('n', 2)]
----

.#*Answer*#
[source,python]
----
 1    # Q1
 2    def my_min(lst):
 3        min_el = lst[0]
 4        for el in lst:
 5            if el < min_el:
 6                min_el = el
 7        return min_el
 8
 9    # Q2
10    def contains(it, x):
11        for el in it:
12            if el == x:
13                return True
14        return False
15
16    # Q3
17    def count_char(s):
18        char2freq = {}
19        for c in s:
20            f = char2freq.setdefault(c, 0)
21            char2freq[c] = f + 1
22        return char2freq
23
24    # Q4
25    def dict_to_list(d):
26        lst = []
27        for k, v in d.items():
28            lst.append((k, v))
29        return lst
----

==== *Challenge:* List Comprehension

Up until now, you learned a few ways to create lists. These are couple possible ways to define a list containing numbers from 1 through 10:

[source,python]
----
# Method 1
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# Method 2
a = []
for i in range(1, 11):
    a.append(i)
----

What if you wanted a list to contain numbers from 1 through 100? Method 1 will be too cumbersome, and method 2 needs three lines just to initialize one list. Can we do better? We can by using list comprehension, which is a more elegant way of defining lists by using the _for_ keyword.

*Basic Structure*

A list comprehension uses the following format:

[source,python]
----
[expression for element in iterable]
----

For example, if you wanted to create a list containing numbers from 1 to 100 with list comprehension, it would look like this:

[source,python]
----
a = [i for i in range(1, 101)]

# Compare to using for loop
a = []
for i in range(1, 101):
    a.append(i)
----

You can modify the `expression` portion to get more specific results. For example, if you wanted a list that contains all the square numbers from 1 to 10, it would look like this:

[source,python]
----
a = [i * i for i in range(1, 11)]
# or
a = [i ** 2 for i in range(1, 11)]

# Compare to using for loop
a = []
for i in range(1, 11):
    a.append(i * i)
----

.#*Exercise 5.6: List Comprehension Basics*#
----
Q1. Create a list containing each character of the string 'HelloWorld'.
Q2. Create a list containing [0.1, 0.2, 0.3, ..., 1.0].
Q3. Create a list containing 5 zeroes (i.e. [0, 0, 0, 0, 0]).
----

#*Answer*#
[source,python]
----
1    # Q1
2    a = [c for c in 'HelloWorld']
3    # Q2
4    b = [i / 10 for i in range(1, 11)]
5    # Q3
6    c = [0 for i in range(5)]
----

*List Comprehension with Conditionals*

You can also use conditionals with list comprehension to add more selectivity. It follows this format:

[source,python]
----
[expression for element in iterable if condition]
----

For example, if you wanted to create a list that contains all even numbers up to 10, it would look like this:

[source,python]
----
a = [i for i in range(11) if i % 2 == 0]

# Compare to using for loop
a = []
for i in range(11):
    if i % 2 == 0:
        a.append(i)
----

.#*Exercise 5.7: List Comprehension with Conditionals*#
----
Q1. a) Create a list containing every odd numbers up to 10 with conditionals.
    b) Do part (a) without using conditionals.

Q2. Create a list containing all uppercased words of the list ['abc', 'CAT', 'DOG', 'apple', 'HelLO'].

The resulting list should be ['CAT', 'DOG'].

For more practice, try writing each of them with for loops and compare it with list comprehension. Try to see which part of the for loop corresponds to which of list comprehension.
----

#*Answer*#
[source,python]
----
1    # Q1 (a)
2    a = [i for i in range(10) if i % 2 == 1]
3    # Q1 (b)
4    a = [i for i in range(1, 10, 2)]
5    a = [i * 2 + 1 for i in range(10 // 2)]
6
7    # Q2
8    lst = ['abc', 'CAT', 'DOG', 'apple', 'HelLO']
9    b = [word for word in lst if word.upper() == word]
----

==== _for_ Loop Practice Problems

.*Question 1*
----
Count the number of even numbers in a list and print the number. You may create a list and fill it with arbitrary values.
----

.*Answer*
[source,python]
----
1    count, lst = 0, [...]  # arbitrary values
2    for n in lst:
3        if n % 2 == 0:
4            count += 1
5    print(count)
----

.*Question 2*
----
Get two lines of user input of multiple values separated by a single comma. Convert each line into one list. For example,

    Input: a,b,c,d
           1,2,3,4
    -> Two lists: ['a', 'b', 'c', 'd']
                  ['1', '2', '3', '4']

Using the two lists, create a new dictionary with the elements of the first list as keys and the elements of the second list as values. Assume that there are no duplicate elements in the first list. Print the dictionary. If the lengths of the lists are different, set the length of the smaller list as the length of the dictionary. For example,

    Ex1) Input : a,b,c,d
                 1,2,3,4
         Output: {'a': '1', 'b': '2', 'c': '3', 'd': '4'}
    Ex2) Input : a,b,c
                 1,2,3,4,5
         Output: {'a': '1', 'b': '2', 'c': '3'}

You may use the built-in min() function to find out the length of the smaller list.

    min(3, 2) -> 2
    min('a', 'b') -> 'a'
----

.*Answer*
[source,python]
----
1    lst1 = input().split(',')
2    lst2 = input().split(',')
3    n = min(len(lst1), len(lst2))
4    d = {}
5
6    for i in range(n):
7        d[lst1[i]] = lst2[i]
8    print(d)
----

.*Question 3*
----
Get a user input of a postive integer. Check if the number has more than four factors. Print 'more than 4 factors' if it does, and print the number of factors if it does not.

        Ex1) Input : 16
             Output: more than 4 factors
             Explanation: 16 has 5 factors (1, 2, 4, 8, 16)
        Ex2) Input : 9
             Output: 3 factors
             Explanation: 9 has 3 factors (1, 3, 9)

Hint: Start approaching this problem as a prime number problem (Exercise 5.4).
----

.*Answer*
[source,python]
----
1    n, factors = int(input()), 2  # because 1 and n are factors
2    for i in range(2, n):
3        if n % i == 0:
4            factors += 1
5        if factors > 4:
6            print('more than 4 factors')
7            break
8    else:
9        print(factors, 'factors')
----

=== _while_ Loops

Whereas in _for_ loops, you had a variable that iterated over elements of a sequence, _while_ loops will continue to loop as long as a certain condition is fulfilled.

.*Structure of a _while_ loop*
[source,python]
----
1    while <condition>:
2        <action>
----

A `<condition>` should be a variable, expression, or something else that evaluates to a boolean value. As long as `<condition>` evaluates to `True`, the action inside the loop would be executed.

Step-by-step execution of a _while_ loop is as follows:

. `<condition>` is evaluated.
. If the boolean value is
.. `True`, execute the action and loop back to step 1
.. `False`, exit _while_ loop

.*_while_ Loop Example 1*
[source,python]
----
1    x = 0
2    while x < 3:
3        print(x)
4        x += 1
----

.*Output*
----
0
1
2
----

This _while_ loop is printing numbers that is less than 3 (starting from 0). How is this _while_ loop being executed?

[%header,cols=6,cols="^.^12%,^.^12%,^.^19%,^.^19%,^.^19%,^.^19%"]
|====
2+| | Loop 1 | Loop 2 | Loop 3 | Loop 4
h| Variable | `x` | [fira-code]#0# | [fira-code]#1# | [fira-code]#2# | [fira-code]#3#
h| Condition | `x < 3` | [fira-code]#True# | [fira-code]#True# | [fira-code]#True# | [fira-code]#False#
.2+h| Action | `print(x)` | Prints `0` | Prints `1` | Prints `2` |
| `x += 1` | [fira-code]#x = 1# | [fira-code]#x = 2# | [fira-code]#x = 3# |
|====

From this table, we can see that even though the `<action>` (lines 3-4) is executed 3 times, the `<condition>` is checked 4 times. Before the _while_ loop is exited, the condition has to evaluate to `False` first. Hence, the `<condition>` is checked one more time than the number of executions of `<action>`.

.*_while_ Loop Example 2*
[source,python]
----
1    num = int(input('Input a number less than 10: '))
2    while num >= 10:
3        num = int(input('Input a number less than 10: '))
4    # ... more actions
----

What is this example doing? Let's break it down step-by-step. First step was to evaluate the `<condition>`, which is `num >= 10`. If `num` is greater than or equal to `10`, line 3 would be executed. On the contrary, if `num` is less than `10`, the interpreter will exit the _while_ loop and continue on to line 4.

====
The _while_ loop would be executed as long as the variable `num` is holding a value that is greater than or equal to `10`.
====

We figured out what the condition is. Next, what is the `<action>` doing? On line 3, the program is asking for a user input. If we read the prompt message, we can see that the program wants the user to input a number that is less than 10. This user input is then stored inside the variable `num`. If we combine `<condition>` and `<action>`, we get:

====
The _while_ loop would be executed as long as the user inputs a value that is greater than or equal to `10`.
====

The above is one way to do an _input check_. This is when we try to account for user mistakes. If we look at the previous example, we can tell that the variable `num` is supposed to hold a number value that is less than 10. But what if the user inputs `11`? `num` would be holding an invalid numerical value. To _catch_ such user mistakes, we can use a _while_ loop to keep asking the user for a valid number.

.#*Exercise 5.8: Write your own _while_ loop*#
----
Take user input of 10 integers. Print out the sum and average of the 10 numbers. Assume the user inputs are correct.
----

.#*Answer*#
[source,python]
----
1    i, sum = 0, 0
2    while i < 10:
3        sum += int(input('Input an integer: '))
4        i += 1
5    print(sum, sum / 10)
----

.#*Exercise 5.9: What is this program doing?*#
[source,python]
----
1    # What is the relationship between the user input and the printed output
2    # Assume the user input is a positive integer
3
4    num, mystery_num = int(input()), 1
5    print(num)
6    while num > 0:
7        mystery_num *= num
8        num -= 1
9    print(mystery_num)
----

.#*Answer*#
----
mystery_num is the factorial of num.
----

==== Infinite Loops

Infinite loops are loops that are repeated endlessly, either intentionally or accidentally.

.*Infinite _while_ Loop*
[source,python]
----
1    x = 1
2    while x >= 0:
3        x += 1
----

The _while_ loop will keep executing as long as `x` is a positive number. In line 1, the value 1 is stored in `x`, and line 3 keeps incrementing ``x``'s value by 1. Therefore, `x` will always be positive, causing the loop to repeat continuously. To prevent these kinds of accidents, it is important to use the correct condition.

However, there are intentional uses of infinite loops.

.*Infinite _while_ Loop*
[source,python]
----
1    print('Input a command')
2    while True:
3        cmd = input()
4        if cmd == 'quit':
5            break
6        # execute command
7    ...
----

The above infinite _while_ loop can be used to continue taking user input until the user wants to 'quit' the program. The loop continues endlessly because the condition is set to `True`. In this case, the loop will continue until the user inputs the word `'quit'`. Then the condition at line 4 will evaluate to `True`, and the interpreter will break out of the _while_ loop and continue on to line 7.

The previous example can also be written with a non-infinite _while_ loop.

.*Infinite _while_ Loop Equivalent*
[source,python]
----
1    print('Input a command')
2    cmd = input()
3    while cmd != 'quit':
4        # execute command
5        cmd = input()
6    ...
----

While they both accomplish the same thing, the thought process behind the two programs are different. The infinite _while_ loop example is a _repeat-until_ loop whereas the second example is a _repeat-until_ loop (or just a _while_ loop).

The infinite loop is called a _repeat-until_ loop because we *repeat* lines 3-6 *until* the user inputs `'quit'`. If you want to repeat certain actions until a condition is met, you can use the infinte _while_ loop pattern and break once that condition is met.

If you want to convert a _repeat-until_ loop to a non-infinite _while_ loop, you can invert the condition. If we compare the condition in line 4 of the first example (`cmd == 'quit'`) and the condition in line 3 of the second example (`cmd != 'quit'`), we can see that they are inverted versions of each other.

.#*Exercise 5.10: Write your own program*#
[source,python]
----
1    # Q1: Convert the following program to an infinite while loop
2
3    num = int(input('Input a number less than 10: '))
4    while num >= 10:
5        num = int(input('Input a number less than 10: '))
----

.#*Answer*#
[source,python]
----
1    while True:
2        num = int(input('Input a number less than 10: '))
3        if num < 10:
4            break
----

==== _while_ Loop Practice Problems

.*Question 1*
----
Get a user input of two positive integers, x and y. How you choose to receive the inputs is up to you. Print out the value of x ** y (x raised to the power of y). Evaluate the value using a while loop. You cannot use the ** operator or the math module to evaluate the output. Assume that the inputs are always valid.
----

.*Answer*
[source,python]
----
1    x, y, power = int(input()), int(input()), 1
2    while y > 0:
3        power *= x
4        y -= 1
5    print(power)
----

.*Question 2*
[subs=+quotes]
----
Do *Question 2* under the *_for_ Loop Practice Problems* section, except this time, check that the two lists are the same length. If they are not, keep asking the user for valid inputs.

    Ex1) Input : Please enter equal number of values
                 a,b,c,d
                 1,2,3,4
         Output: {'a': '1', 'b': '2', 'c': '3', 'd': '4'}
    Ex2) Input : Please enter equal number of values
                 a,b,c
                 1,2,3,4,5
                 Please enter equal number of values
                 a,b,c,d
                 1,2,3
                 Please enter equal number of values
                 a,b,c
                 1,2,3
         Output: {'a': '1', 'b': '2', 'c': '3'}

The part in blue is the actual user input.
----

.*Answer*
[source,python]
----
# Method 1
 1    lst1 = input('Please enter equal number of values\n').split(',')
 2    lst2 = input().split(',')
 3    while len(lst1) != len(lst2):
 4        lst1 = input('Please enter equal number of values\n').split(',')
 5        lst2 = input().split(',')
 6    d = {}
 7
 8    for i in range(len(lst1)):  # or len(lst2)
 9        d[lst1[i]] = lst2[i]
10    print(d)

# Method 2 - Infinite while loop
 1    while True:
 2        lst1 = input('Please enter equal number of values\n').split(',')
 3        lst2 = input().split(',')
 4        if len(lst1) == len(lst2):
 5            break
 6    d = {}
 7
 8    for i in range(len(lst1)):  # or len(lst2)
 9        d[lst1[i]] = lst2[i]
10    print(d)
----

.*Question 3*
----
A list has a reverse() method that reverses the list. In this problem, reverse a list using only a while loop and no reverse() method, then print out the reversed list. Receive the original list as user input. Each element will be separated by a single comma. You may reverse the original list directly or create a new reversed list.

    Ex) Input : 1,2,3,abc,hello
        Output: ['hello', 'abc', '3', '2', '1']
----

.*Answer*
[source,python]
----
# Option 1: Reverse directly
1    lst = input().split(',')
2    i, n = 0, len(lst)
3    while i < n // 2:
4        lst[i], lst[n - i - 1] = lst[n - i - 1], lst[i]
5        i += 1
6    print(lst)

# Option 2: Create a new list (for loop is better)
1    lst = input().split(',')
2    n, new_lst = len(lst), ['' for i in range(len(lst))]
3    for i in range(n):
4        new_lst[i] = lst[n - i - 1]
5    print(new_lst)
----

=== The _continue_ Keyword

While going over infinite loops in the previous section, we covered the `break` keyword. It was used to prematurely exit a _while_ or _for_ loop once a certain condition was met. Similarly, the `continue` keyword can be used to prematurely end a single iteration if a certain condition is met.

[source,python]
----
 1    print('break example')
 2    for i in range(1, 6):
 3        if i % 2 == 0:
 4            break
 5        print(i)
 6
 7    print('continue example')
 8    for i in range(1, 6):
 9        if i % 2 == 0:
10            continue
11        print(i)
----

.*Output*
----
break example
1
continue example
1
3
5
----

This example shows the difference of `break` and `continue`. Using `break` will cause the whole loop to be terminated, whereas `continue` causes the current iteration to be completed. Once the program reaches line 4, the _for_ loop is exited. However, once the program reaches line 10, line 11 is skipped and `i` moves on to the next number in sequence.

The `continue` keyword can be used to skip over unnecessary parts when a certain condition is met. While not used too often, it can be helpful in reducing lines of code.

=== Difference Between _for_ and _while_

Both loops are similar in the sense that they, well, loop. They repeat certain actions for a number of times. So why is there two loops, and when should we use which?

.*Print 0 to 3: _for_ Loop*
[source,python]
----
1    for i in range(4):
2        print(i)
----

.*Print 0 to 3: _while_ Loop*
[source,python]
----
1    i = 0  # assign variable
2    while i < 4:
3        print(i)
4        i += 1  # increment variable
----

Immediately, we can tell that the _while_ loop uses two more lines: one to assign a value to the variable to be used in condition-checking and another to alter the value of that variable. Since the variable created in a _for_ loop iterates over a set sequence of numbers, there is no need to manually change the value yourself.

But what about the following example that we have covered earlier?

[source,python]
----
1    num = int(input('Input a number less than 10: '))
2    while num >= 10:
3        num = int(input('Input a number less than 10: '))
----

It is hard to come up with an equivalent for the _for_ loop because there isn't a set sequence a variable can iterate through. As such, if you need to repeat certain actions as long as a non-sequential condition is met, you should use a _while_ loop.

[%header,cols=2]
|====
2+^| Difference between _for_ and _while_
^h| _for_ loop ^h| _while_ loop

a| * Don't need to create or alter values of variables
a| * Need to create a variable to be used in the condition and alter the value of it in the body

a| * Should use when iterating through a sequence of values
a| * Should use when you need to repeat certain actions until a certain condition is met
|====

<<<

=== Practice Problems

#*A. Evaluate the output*#

*A-1*
[source,python]
----
1    n = 0
2    for c in 'helloworld':
3        if c in 'aeiou':
4            n += 2
5            continue
6        n += 1
7    print(n)
----

*Answer*
----
13
----

*A-2*
[source,python]
----
1    colors = ['red', 'blue', 'green']
2    objects = ['pen', 'book', 'cup']
3
4    for c in colors:
5        for obj in objects:
6            print(c, obj)
----

*Answer*
----
red pen
red book
red cup
blue pen
blue book
blue cup
green pen
green book
green cup
----

*A-3*
[source,python]
----
1    n = 512
2    while n > 1:
3        print('Looping')
4        n //= 2
5    # How many times would Looping be printed if n = 513? Why?
----

*Answer*
----
Looping
Looping
Looping
Looping
Looping
Looping
Looping
Looping
Looping
# 10 times bc it loops ceil(log2(n)) times
# e.g. n = 512 = 2^9, so looped 9 times
----

*A-4*
[source,python]
----
 1    a = sorted([9, 2, 15, 6, 3, 4, 5, 17, 20, 16, 10])
 2    n = 17
 3    while True:
 4        mid = len(a) // 2
 5        if a[mid] == n:
 6            print('Found')
 7            break
 9        if a[mid] > n:
10            a = a[:mid]
11        else:
12            a = a[mid+1:]
13        print(a)
----

*Answer*
----
[10, 15, 16, 17, 20]
[17, 20]
[17]
Found
----

#*B. Find any errors in following Python programs*#

*B-1*
[source,python]
----
1    lst = list(range(10))
2    for i in range(len(lst)):
3        if lst[i] % 2 == 1:
4            del lst[i]
5    # lst should contain only even numbers
----

*Answer*
[source,python]
----
 1    # Should not modify list elements when iterating through it
 2    # Alternative 1: Use the while loop
 3    lst = list(range(10))
 4    count = 0
 5    while count < len(lst):
 6        if lst[count] % 2 == 1:
 7            del lst[count]
 8            continue
 9        count += 1
10
11    # Alternative 2: Use list comprehension
12    lst = list(range(10))
13    lst = [x for x in lst if x % 2 == 0]
14
15    # Alternative 3: Use step
16    lst = list(range(0, 10, 2))
----

*B-2*
[source,python]
----
1    lst = [9, 3, 5, 10, 11, 7]
2    i = 0
3    while i < len(lst) - 1:
4        j = 0
5        while j < len(lst) - i - 1:
6            if lst[j] > lst[j + 1]:
7                lst[j], lst[j + 1] = lst[j + 1], lst[j]
8    # lst is sorted through bubblesort
----

*Answer*
----
The variables i, j are not modified inside the while loop causing the loop to go on infinitely.
Add the statements j += 1 and i += 1 between lines 7 and 8.
----

*B-3*
[source,python]
----
1    words = ['apple', 'fruit', 'owl', 'ink']
2    for word in words:
3        result = []
4        if word.startswith(('a', 'e', 'i', 'o', 'u')):
5            result.append(word)
6    # result contains words that start with a vowel
----

*Answer*
----
Because result was defined inside the for loop, it will contain only one element at the end (-> ['ink']).
Define result outside the for loop.
----

#*C. Write your own program*#

*C-1*

----
Get a user input of words/sentences separated by a single comma. Then output the string containing the greatest number of vowels.

    Ex) Input : apple,bananas are tasty,i like pie
        Output: bananas are tasty
----

*Answer*
[source,python]
----
 1    words = input().split(',')
 2
 3    max, max_s = -1, ''
 4    for s in words:
 5        sum = 0
 6        for v in 'aeiou':
 7            sum += s.count(v)
 8        if sum > max:
 9            max, max_s = sum, s
10    print(max_s)
----

*C-2*

----
Get a user input of one nonnegative integer and check if input is valid. Then print the sum of the digits of that number.
----

*Answer*
[source,python]
----
 1    # Example 1
 2    n1 = input('Nonnegative integer: ')
 3    while not n1.isnumeric():
 4        n1 = input('Please input a nonnegative integer: ')
 5
 6    sum1 = 0
 7    for s in n1:
 8        sum1 += int(s)
 9    print(sum1)
10
11    # Example 2
12    n2 = input('Nonnegative integer: ')
13    while not n2.isnumeric():
14        n2 = input('Please input a nonnegative integer: ')
15
16    n2, sum2 = int(n2), 0
17    while n2 > 0:
18        sum2 += n2 % 10
19        n2 //= 10
20    print(sum2)
----

*C-3*

----
The Collatz Conjecture states that for any positive integer, if we repeat the following operations, then the number will eventually reach 1:

    * If n is even, divide n by 2
    * If n is odd, multiply n by 3 and add 1

Ask the user for a positive integer. Then repeat the above operations until it reaches 1. Make sure to validate the user's input. Print n at the end of each step.
----

*Answer*
[source,python]
----
 1    n = input('Positive integer: ')
 2    while not n.isnumeric() or n == '0':
 3        n = input('Please input a positive integer: ')
 4
 5    n = int(n)
 6    while n != 1:
 7        if n % 2 == 0:
 8            n //= 2
 9        else:
10            n = 3 * n + 1
11        print(n)
----

*C-4*

----
Make a program to find the mean and median of some integers. Get user input of integers one by one until the user inputs an empty line (i.e. if input is an empty string). Assume the input is always correct.
----

*Answer*
[source,python]
----
 1    numbers = []
 2    x, n = input(), 0
 3    while x != '':
 4        numbers.append(int(x))
 5        x, n = input(), n + 1
 6
 7    # Mean
 8    mean = sum(numbers) / n
 9
10    # Median
11    numbers.sort()
12    if n % 2 == 0:
13        med = (numbers[n // 2 - 1] + numbers[n // 2]) / 2
14    else:
15        med = numbers[n // 2]
16
17    print('Mean: {}, Median: {}'.format(mean, med))
----





